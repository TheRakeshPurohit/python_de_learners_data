[
  {
    "algo": "LinkedList",
    "supp_class": "LinkingNode",
    "supp_code": "class Lnode:\n    def __init__(self, val):\n        self.val = val\n        self.next = NonePaste the code here",
    "main_class": "LinkedList",
    "init_code": "class LinkedList(object):\n    def __init__(self):\n        self.head = None",
    "num_methods": 4,
    "methods": [
      {
        "name": "Append_loop",
        "code": "    def append_by_loop(self, val):\n        if self.head is None:\n            self.head = Lnode(val)\n            return\n        curr = self.head\n        while curr.next is not None:\n            curr = curr.next\n        curr.next = Lnode(val)\n        return"
      },
      {
        "name": "Print_loop",
        "code": "def print_by_loop(self):\n        store = \"\"\n        if self.head is None:\n            print('empty')\n            return\n\n        curr = self.head\n        while curr.next is not None:\n            store += str(curr.val) + ' '\n            curr = curr.next\n        store += str(curr.val)\n        print(store)\n        return"
      },
      {
        "name": "contains_loop",
        "code": "    def contains_by_loop(self, val):\n        if self.head is None:\n            print(False)\n            return\n        curr = self.head\n        while curr.next is not None:\n            if curr.val == val:\n                print(True)\n                return\n            curr = curr.next\n        print(False)\n        return"
      },
      {
        "name": "delete_loop",
        "code": "    def delete_by_loop(self, val):\n        if self.head is None:\n            return\n        if self.head.val == val:\n            del_node = self.head\n            self.head = self.head.next\n            print(del_node.val)\n            return\n\n        prev = self.head\n        curr = None\n\n        while prev.next is not None:\n            curr = prev.next\n            if curr.val == val:\n                prev.next = curr.next\n                return\n            prev = curr\n        return"
      }
    ]
  },
  {
    "algo": "Queue",
    "supp_class": "QueueNode",
    "supp_code": "class QNode:\n    def __init__(self, val) -> None:\n        self.val = val\n        self.next = None",
    "main_class": "Queue",
    "init_code": "class GroQue(object):\n    def __init__(self) -> None:\n        self.front = None\n        self.back = None\n        self.size = 0",
    "num_methods": 3,
    "methods": [
      {
        "name": "Enqueue",
        "code": "    def enqueue(self, val):\n        node = QNode(val)\n        if self.size == 0:\n            self.front = node\n            self.back = node\n        else:\n            self.back.next = node\n            self.back = node\n        self.size += 1\n        return"
      },
      {
        "name": "Print_by_loop",
        "code": "    def print_by_loop(self):\n        if self.size == 0:\n            print('empty')\n            return\n        store = ''\n        curr = self.front\n        while curr is not None:\n            store += str(curr.val) + ' '\n            curr = curr.next\n        print(store)\n        return"
      },
      {
        "name": "Dequeue",
        "code": "    def dequeue(self):\n        if self.size == 0:\n            print('empty')\n        remnode = self.front\n        self.front = self.front.next\n        print(remnode.val)\n        return"
      }
    ]
  },
  {
    "algo": "Graphs",
    "supp_class": "GraphNode",
    "supp_code": "class Gnode(object):\n    def __init__(self, val) -> None:\n        self.val = val\n        self.left = None\n        self.right = None",
    "main_class": "Graph",
    "init_code": "class Grokraph(object):\n    def __init__(self):\n        self.head = None",
    "num_methods": 5,
    "methods": [
      {
        "name": "Connect_by_loop",
        "code": "    def connect(self, val):\n        gnode = Gnode(val)\n        if self.head is None:\n            self.head = gnode\n        else:\n            stk = [self.head]\n            while len(stk) > 0:\n                curr = stk.pop(0)\n                if curr.left is None:\n                    curr.left = gnode\n                    return\n                else:\n                    stk.insert(0, curr.left)\n                if curr.right is None:\n                    curr.right = gnode\n                    return\n                else:\n                    stk.insert(0, curr.right)"
      },
      {
        "name": "Print_loop",
        "code": "    def print_loop(self):\n        stk = [self.head]\n        store = \"\"\n        while len(stk) > 0:\n            curr = stk.pop(0)\n            store += str(curr.val) + ' - '\n            if curr.right is not None:\n                stk.insert(0, curr.right)\n\n            if curr.left is not None:\n                stk.insert(0, curr.left)\n        print(store)\n        return"
      },
      {
        "name": "Build_adjacency_list",
        "code": "def build_adj_list(node):\n    adj_list = []  # Get a store\n    tk = [node]\n    while len(tk) > 0:\n        curr = tk.pop(0)\n        vertices = curr.get_adj_list()\n        adj_list.append(vertices)\n        if len(curr.edgeList) > 0:\n            [tk.insert(0, elem) for elem in curr.edgeList]\n    return adj_list"
      },
      {
        "name": "Build_vertex_list",
        "code": "def build_vertex_list(node, node_list):\n    vert_list = []  # Get a store\n    tk = [node]\n    while len(tk) > 0:\n        curr = tk.pop(0)\n        vertices = curr.get_vertex_list(node_list)\n        vert_list.extend(vertices)\n        if len(curr.edgeList) > 0:\n            [tk.insert(0, elem) for elem in curr.edgeList]\n    return vert_list"
      },
      {
        "name": "Build_Adj_matrix",
        "code": "list_len = len(vertices)\nadj_matrix = [[0 for _ in range(list_len)]\n              for _ in vertices]\n\n\ndef gen_adj_matrix(node, adj_matrix, node_list):\n    vertices = node.gen_vertex_list(node_list)\n    new_am = adj_matrix\n    for vert in vertices:\n        print(vert)\n        new_am[vert[0]][vert[1]] = 1\n    return new_am"
      }
    ]
  },
  {
    "algo": "Stack",
    "supp_class": "StackNode",
    "supp_code": "class SNode(object):\n    def __init__(self, val) -> None:\n        self.val = val\n        self.next = None",
    "main_class": "Stack",
    "init_code": "class GrokStak(object):\n    def __init__(self) -> None:\n        self.top = None\n        self.size = 0",
    "num_methods": 4,
    "methods": [
      {
        "name": "push",
        "code": "    def push(self, val):\n        node = SNode(val) \n        if self.size == 0:\n            self.top = node\n        else:\n            node.next = self.top\n            self.top = node\n        self.size += 1\n        return"
      },
      {
        "name": "pop",
        "code": "    def pop(self):\n        if self.size == 0:\n            return\n        popnode = self.top\n        self.top = self.top.next\n        self.size -= 1\n        print(popnode.val)\n        return"
      },
      {
        "name": "print_by_loop",
        "code": "    def print_by_loop(self):\n        if self.size == 0:\n            print('empty')\n            return\n        curr = self.top\n        store = \"\"\n        while curr.next is not None:\n            store += str(curr.val) + ' '\n            curr = curr.next\n        print(store)\n        return"
      },
      {
        "name": "get_top",
        "code": "    def get_top(self):\n        if self.size == 0:\n            print('empty')\n            return\n        print(self.top.val)\n        return"
      }
    ]
  }
]
